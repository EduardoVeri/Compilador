/* Defines for VGA */

int ORIGINALVGAWIDTH; int ORIGINALVGAHEIGHT;
int currentvgaheight; int currentvgawidth;
int DIVISORFACTOR;

int BALLSIZE;        
int COLORBACKGROUND; int COLORBALL; int COLORBAR;

int BARHEIGHT; int BARWIDTH; int SPACEEDGEBAR; 
int BARSPEED;       

int KEYP2UP; int KEYP2DOWN;

int SLEEPTIME;

int prng_seed;


void sleep(int time) {
    int i;
    i = 0;
    while (i < time) {
        i = i + 1;
    }
}

int mod(int num, int n){
    if (n == 0){
        return 0;
    }
    return num-num/n*n;
}

void seedRandom(int seed) {
    prng_seed = seed;
}

/*
* Generates the next pseudo-random number using an LCG.
* Returns a number between 0 and 2147483646.
*/
int random(void) {
    /* These are the 'magic numbers' for the LCG formula. */
    /* They are from the well-known Park-Miller PRNG. */
    int multiplier;
    int modulus;

    multiplier = 48271;
    modulus = 2147483647; /* A very large prime number (2^31 - 1) */
    
    /* Calculate the next number in the sequence */
    /* Formula: X_n+1 = (a * X_n) % m */
    prng_seed = mod(prng_seed * multiplier, modulus);

    return prng_seed;
}


/* Get a random number in the range [min, max]. */
int randomInRange(int min, int max) {
    int range;
    int randomNumber;

    range = max - min + 1;
    
    randomNumber = mod(random(), range);

    return min + randomNumber;
}


/* Output a value to the Hexa display and wait for a key press. */
void outputAndSleep(int value, int sleeptime) {
    output(value);
    while (keyboardinput() == 0) {
    }
}


/* Draw a pixel at (x, y) on the VGA screen.
* (!) The x zero point is at the top left corner
* (!) and the y zero point is at the top left corner.
*/
void drawpixelVGA(int x, int y, int color) {
    int framebufferindex; 

    /* Out of bounds checks */
    if (x < 0) {
        return; 
    }
    if (x >= currentvgawidth) {
        return; 
    }
    if (y < 0) {
        return; 
    }
    if (y >= currentvgaheight) {
        return; 
    }
    
    framebufferindex = y * currentvgawidth + x;
    
    drawpixel(framebufferindex, color);
}

/* Draws a square ball of 'size' at (x,y) with the specified 'color' */
void printBall(int x, int y, int size, int color){ 
    int i; int j;
    int starty; int endy;
    int startx; int endx;

    starty = y;
    endy = y + size;
    startx = x;
    endx = x + size;
    
    i = starty;
    while(i < endy){
        j = startx;
        while(j < endx){
            drawpixelVGA(j, i, color); 
            j = j + 1;
        } 
        i = i + 1;
    }
}

void printBar(int x, int y, int width, int height, int color) {
    int i; int j;
    int endy;
    int endx;

    endy = y + height;
    endx = x + width;

    /* Basic sanity check for coordinates, though drawpixelVGA also checks */
    if (x < 0) { x = 0; }
    if (y < 0) { y = 0; }
    if (endx > currentvgawidth) { endx = currentvgawidth; }
    if (endy > currentvgaheight) { endy = currentvgaheight; }

    i = y;
    while (i < endy) {
        j = x;
        while (j < endx) {
            drawpixelVGA(j, i, color);
            j = j + 1;
        }
        i = i + 1;
    }
}

/* Create bars and ball */ 
void initFrameVGA(void) {
    int barwidth; int barheight; int ballsize;
    int centerheight; int centerwidth;
    int halfbarheight; int halfballsize;
    int i; int j;
    int spaceedgebar;
    
    spaceedgebar = 1; /* Space from the edge of the screen to the bar */
    barwidth = 2; 
    barheight = 10; 
    
    centerheight = currentvgaheight / 2; /* Center of the screen */
    centerwidth = currentvgawidth / 2;
    halfbarheight = barheight / 2;
    
    /* Draw left bar */
    printBar(SPACEEDGEBAR, 
             centerheight - halfbarheight, 
             BARWIDTH, 
             BARHEIGHT, 
             COLORBAR);

    /* Draw right bar using printBar */
    printBar(currentvgawidth - SPACEEDGEBAR - BARWIDTH, 
             centerheight - halfbarheight, 
             BARWIDTH, 
             BARHEIGHT, 
             COLORBAR);

    halfballsize = (BALLSIZE / 2);
    
    /* Calculate top-left coordinates for the ball to be centered */
    printBall(
        centerwidth - halfballsize, 
        centerheight - halfballsize, 
        BALLSIZE, COLORBALL
    );
}

void game(void){
    int currentPosBar1;     /* Top Y of left/AI bar */
    int oldPosBar1;         /* Previous Y of left/AI bar for clearing */
    int currentPosBar2;     /* Top Y of right/Player bar */
    int oldPosBar2;         /* Previous Y of right/Player bar */
    int rightBarX;          /* X coordinate of the right bar (fixed) */
    int leftBarX;           /* X coordinate of the left bar (fixed) */

    int ballX; int ballY;

    int ballDirectionX; 
    int ballDirectionY; 

    int i;               
    int keypressed;
    int ballSpeed;

    int rightPaddleHit; int leftPaddleHit;
    int score;

    /* Initialize bar Y positions (top of the bar) */
    currentPosBar1 = currentvgaheight / 2 - (BARHEIGHT / 2); 
    currentPosBar2 = currentvgaheight / 2 - (BARHEIGHT / 2);
    oldPosBar1 = currentPosBar1; /* Initialize old position for AI bar */
    oldPosBar2 = currentPosBar2; /* Initialize old position for Player bar */

    /* Calculate fixed X positions for the bars */
    leftBarX = SPACEEDGEBAR; 
    rightBarX = currentvgawidth - SPACEEDGEBAR - BARWIDTH; 

    ballX = currentvgawidth / 2 - (BALLSIZE / 2);
    ballY = currentvgaheight / 2 - (BALLSIZE / 2);
    
    ballDirectionX = 1; 
    ballDirectionY = 1; 
    ballSpeed = 1;      
    i = 0; 
    score = 0; 
    
    while (1){ 
        keypressed = keyboardinput(); 

        oldPosBar2 = currentPosBar2;
        
        /* --- Right Bar (Player 2) Movement --- */
        if (keypressed == KEYP2UP) { 
            if (currentPosBar2 >= BARSPEED) { currentPosBar2 = currentPosBar2 - BARSPEED; } 
            else { currentPosBar2 = 0; }
        } else {
            if (keypressed == KEYP2DOWN) { 
                if (currentPosBar2 + BARHEIGHT + BARSPEED <= currentvgaheight) { currentPosBar2 = currentPosBar2 + BARSPEED; } 
                else { currentPosBar2 = currentvgaheight - BARHEIGHT; }
            }
        }
        
        if (currentPosBar2 < 0) { currentPosBar2 = 0; }
        if (currentPosBar2 + BARHEIGHT > currentvgaheight) { currentPosBar2 = currentvgaheight - BARHEIGHT; }

        if (oldPosBar2 != currentPosBar2) {
            printBar(rightBarX, oldPosBar2, BARWIDTH, BARHEIGHT, COLORBACKGROUND);
            printBar(rightBarX, currentPosBar2, BARWIDTH, BARHEIGHT, COLORBAR);
        }

        /* Game tick for ball and AI movement */
        if (mod(i, SLEEPTIME * 2) == 0){ 
            
            printBall(ballX, ballY, BALLSIZE, COLORBACKGROUND); /* 1. Clear old ball */
            
            /* 2. Update ball position */
            if (ballDirectionY == 0) { /* Moving Up */
                if (ballY >= ballSpeed) { ballY = ballY - ballSpeed; } 
                else { ballY = 0; }
            } else { /* Moving Down */
                ballY = ballY + ballSpeed;
            }

            if (ballDirectionX == 0) { /* Moving Left */
                if (ballX >= ballSpeed) { ballX = ballX - ballSpeed; } 
                else { ballX = 0; }
            } else { /* Moving Right */
                ballX = ballX + ballSpeed;
            }

            /* --- Left Bar (Player 1) AI Movement --- */
            oldPosBar1 = currentPosBar1; /* Store previous position */

            /* AI tries to center its paddle on the ball's Y position */
            currentPosBar1 = ballY + (BALLSIZE / 2);
            if (currentPosBar1 > (BARHEIGHT / 2)){
                currentPosBar1 = currentPosBar1 - (BARHEIGHT / 2);
            } else {
                currentPosBar1 = 0; /* If ball is too high, keep AI paddle at top */
            }

            /* Clamp the AI paddle's position to stay within screen bounds */
            if (currentPosBar1 < 0) {
                currentPosBar1 = 0;
            }
            if (currentPosBar1 + BARHEIGHT > currentvgaheight) {
                currentPosBar1 = currentvgaheight - BARHEIGHT;
            }

            /* Redraw the AI bar only if it has moved */
            if (oldPosBar1 != currentPosBar1) {
                printBar(leftBarX, oldPosBar1, BARWIDTH, BARHEIGHT, COLORBACKGROUND);
                printBar(leftBarX, currentPosBar1, BARWIDTH, BARHEIGHT, COLORBAR);
            }
            
            /* 3. Ball collision detection and response */
            
            /* Vertical wall collisions */
            if (ballDirectionY == 0) { 
                if (ballY == 0) { ballDirectionY = 1; }
            } else { 
                if (ballY + BALLSIZE >= currentvgaheight) { 
                    ballY = currentvgaheight - BALLSIZE; 
                    ballDirectionY = 0; 
                }
            }
            
            /* Horizontal collisions (Paddles and Left/Right walls) */
            if (ballDirectionX == 0) { /* If ball was moving Left */
                leftPaddleHit = 0; 

                /* Check collision with LEFT PADDLE (AI) */
                if (ballX <= (leftBarX + BARWIDTH)) {
                    if ((ballX + BALLSIZE) > leftBarX) {
                        if ((ballY + BALLSIZE) > currentPosBar1) {
                            if (ballY < (currentPosBar1 + BARHEIGHT)) {
                                /* --- LEFT PADDLE HIT --- */
                                ballDirectionX = 1; /* Bounce Right */
                                ballX = leftBarX + BARWIDTH; /* Reposition ball */
                                leftPaddleHit = 1;
                            }
                        }
                    }
                }
                
                /* If NO left paddle hit, check for far LEFT WALL */
                if (leftPaddleHit == 0) {
                    if (ballX == 0) {
                        ballDirectionX = 1;
                        score = score + 1; /* Player 2 scores */
                    }
                }
            } else { /* If ball was moving Right */
                rightPaddleHit = 0; 

                /* Check collision with RIGHT PADDLE (Player) */
                if ((ballX + BALLSIZE) >= rightBarX) {
                    if (ballX < (rightBarX + BARWIDTH)) {
                        if ((ballY + BALLSIZE) > currentPosBar2) {
                            if (ballY < (currentPosBar2 + BARHEIGHT)) {
                                /* --- RIGHT PADDLE HIT --- */
                                ballDirectionX = 0;
                                if (BALLSIZE > 0) { ballX = rightBarX - BALLSIZE; } 
                                else { ballX = rightBarX; }
                                rightPaddleHit = 1;
                            }
                        }
                    }
                }

                /* If NO right paddle hit, check for far RIGHT WALL */
                if (rightPaddleHit == 0) {
                    if ((ballX + BALLSIZE) >= currentvgawidth) { 
                        ballX = currentvgawidth - BALLSIZE;
                        ballDirectionX = 0;
                        if (score > 0){ score = score - 1; } /* Player 1 (AI) scores */
                    }
                }
            }

            printBall(ballX, ballY, BALLSIZE, COLORBALL); /* 4. Draw new ball */
        }
        
        i = i + 1; 
        output(score);        
        sleep(SLEEPTIME); 
    }
}

int main(void){
    int seed_counter;

    DIVISORFACTOR = 16;
    ORIGINALVGAWIDTH = 640;
    ORIGINALVGAHEIGHT = 480;

    COLORBALL = 3;
    COLORBAR = 5;
    COLORBACKGROUND = 0; 
    BALLSIZE = 1;    

    BARHEIGHT = 10;     /* Define bar height */
    BARWIDTH = 2;       /* Define bar width */
    SPACEEDGEBAR = 1;   /* Define space from edge */
    BARSPEED = 1;      /* Define bar movement speed */

    SLEEPTIME = 83; /* How many iter to get ~1ms */

    KEYP2UP = 29; 
    KEYP2DOWN = 27; /* W and S keys for Player 2 */
    
    currentvgawidth = ORIGINALVGAWIDTH / DIVISORFACTOR;
    currentvgaheight = ORIGINALVGAHEIGHT / DIVISORFACTOR;

    initFrameVGA(); /* Create the bars and ball */


    /* --- Seeding the Random Number Generator --- */
    /* This simple method creates a variable seed based on how long */
    /* the player waits before pressing a key to start the game. */
    /* You would need to print a "Press any key to start" message first. */
    seed_counter = 1;
    while (keyboardinput() == 0) { /* Wait for any key press */
        seed_counter = seed_counter + 1;
    }
    seedRandom(seed_counter); /* Seed with the resulting number */

    /* --- Start the Game --- */
    game();
    output(1); 

    return 0;
}